#!/usr/bin/env python3
"""
PornHubScanner is a small program made to  let you watch porn videos
in a safe and privacy friendly manner. No more cookies, no more
embarassing browser cache problems, plus no need for flashplayer. The
script relies on qt4 for the gui and on BeautifulSoup library for the
page scraping.
"""

import os
import sys
import urllib.request
import subprocess

from PyQt4 import QtGui
from PyQt4.QtCore import QThread

from phscanner.interfaces import error_dialog, downloader, main
from phscanner.site import PornHub
from phscanner.actions import Download


def get_coordinates(width, height):
    """Provides the x and y coordinates to center the widget."""
    desk = QtGui.QApplication.desktop()
    return (desk.width() - width) / 2, (desk.height() - height) / 2


class DialogWindow(QtGui.QDialog, error_dialog.Ui_Dialog):
    """Class to manage popup dialog."""
    def __init__(self, message):
        super().__init__()
        self.setupUi(self)
        self.label.setText(message)
        x, y = get_coordinates(self.width(), self.height())
        self.setGeometry(x, y, self.width(), self.height())


class DownloaderWindow(QtGui.QWidget, downloader.Ui_Download):
    """Class to manage the downloader window."""
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        x, y = get_coordinates(self.width(), self.height())
        self.setGeometry(x, y, self.width(), self.height())

    def update_progress(self, percentage):
        """Update progressbar with the received value."""
        self.progressBar.setValue(percentage)

    def closeEvent(self, event):
        # If windows is closed, simulate a click of the abortButton.
        self.abortButton.click()


class MainWindow(QtGui.QMainWindow, main.Ui_MainWindow):
    """Class to manage the behaviour of the main window."""
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.site = PornHub()
        self.catalogue = {}
        self.dlthread = None
        self.downloader = None

        # Center the window
        x, y = get_coordinates(self.width(), self.height())
        self.setGeometry(x, y, self.width(), self.height())

        # Connect signals to methods
        self.scanButton.clicked.connect(self.scan)
        self.videoList.itemDoubleClicked.connect(self.action)

    def scan(self):
        """Store titles and addresses in a key-value format."""
        self.catalogue.clear()
        self.site.page = self.pageBox.value()

        try:
            self.catalogue = self.site.get_catalogue()
        except (urllib.error.HTTPError, urllib.error.URLError):
            self.lineEdit.setText('Cannot reach the given page!, sorry!')
        else:
            self.videoList.addItems(list(self.catalogue.keys()))

    def action(self, selected_item):
        """Manage the selected action for the video."""
        selected = selected_item.text()

        try:
            url = self.site.get_video_url(self.catalogue[selected])
        except (urllib.error.HTTPError, urllib.error.URLError):
            print('Cannot reach video page, sorry!')
        except (AttributeError, KeyError):
            print('Cannot retrieve video url, sorry!')
        else:
            if self.actionBox.currentText() == 'Play mode':
                players = ['/usr/bin/vlc', '/usr/bin/totem']
                for i in players:
                    try:
                        subprocess.Popen([i, url])
                    except FileNotFoundError:
                        if i == players[-1]:
                            msg = 'Cannot find a supported player!'
                            self.d = DialogWindow(msg)
                            self.d.show()
                            break
                    except TypeError:
                        pass
                    else:
                        break
            else:
                # Selected action is 'Download'. We create a separate
                # QThread instance and a downloader instance, than we
                # move the latter to the first
                self.dlthread = QThread()
                self.dlproc = Download(url, selected)
                self.dlproc.moveToThread(self.dlthread)

                # connect signals
                self.dlthread.started.connect(self.dlproc.start_process)
                self.dlthread.finished.connect(self.download_done)
                self.dlproc.finished.connect(self.dlthread.quit)

                # Create and manage an instance of the DownloaderWindow
                self.dw = DownloaderWindow()
                self.dlproc.report.connect(self.dw.update_progress)
                self.dw.abortButton.clicked.connect(self.download_done)

                # Disable the video list while an action is performing
                self.videoList.setDisabled(True)

                # Start the job
                try:
                    self.dlthread.start()
                except:
                    print('ff')
                else:
                    self.dw.show()

    def download_done(self):
        """Manage stuff  when download is stopped or complete."""
        if self.dlthread.isRunning():
            self.dlproc.exiting = True
            self.dlthread.quit()
            self.dlthread.wait()
            os.remove(self.dlproc.video_title)

        # update interface
        self.videoList.setEnabled(True)
        self.dw.close()

    def closeEvent(self, event):
        """Executed when main thread is closed."""
        if self.dlthread:
            self.download_done()


def main():
    app = QtGui.QApplication(sys.argv)
    window = MainWindow()
    window.show()
    app.exec_()

if __name__ == '__main__':
    main()
